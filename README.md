# workflow
Asyncronous Parralel Networking and Computing Engine
A server engine that allows you to holistically integrate your tasks including all search services, cloud input method, online advertisements, etc., handling more than 100 000 requests per second. This is an enterprise-level programming engine based on Sogou's server engine in light and elegant design which can satisfy most C++ back-end development requirements. 
Common use cases include (but not limited to) : 
1. Building an HTTP server with a multifunctional asynchronous client,currently supporting HTTP, Redis, MySQL and Kafka protocols.
2. Service governance, a seamless mechanism to manage the services we depend on
3. An algorithm factory, which provides some common computing tasks, such as sorting, merging, etc.
4. Parallel Ligtning Network Smart Contract deployment on the mainnet

System design features

We believe that a typical back-end program=protocol+algorithm+workflow and should be developed completely independently.

    Protocol
        In most cases, users use built-in common network protocols, such as HTTP, Redis or various rpc.
        Users can also easily customize user-defined network protocol. In the customization, they only need to provide serialization and deserialization functions to define their own client/server.
    Algorithm
        In our design, the algorithm is a concept symmetrical to the protocol.
            If protocol call is rpc, then algorithm call is an apc (Async Procedure Call).
        We have provided some general algorithms, such as sort, merge, psort, reduce, which can be used directly.
        Compared with a user-defined protocol, a user-defined algorithm is much more common. Any complicated computation with clear boundaries should be packaged into an algorithm.
    Workflow
        Workflow is the actual business logic, which is to put the protocols and algorithms into the flow graph for use.
        The typical workflow is a closed series-parallel graph. Complex business logic may be a non-closed DAG.
        The workflow graph can be constructed directly or dynamically generated based on the results of each step. All tasks are executed asynchronously.

Basic task, task factory and complex task

    Our system contains six basic tasks: networking, file IO, CPU, GPU, timer, and counter.
    All tasks are generated by the task factory and automatically recycled after callback.
        Server task is one kind of special networking task, generated by the framework which calls the task factory, and handed over to the user through the process function.
    In most cases, the task generated by the user through the task factory is a complex task, which is transparent to the user.
        For example, an HTTP request may include many asynchronous processes (DNS, redirection), but for user, it is just a networking task.
        File sorting seems to be an algorithm, but it actually includes many complex interaction processes between file IO and CPU computation.
        If you think of business logic as building circuits with well-designed electronic components, then each electronic component may be a complex circuit.

Asynchrony and encapsulation based on C++11 std::function

    Not based on user mode coroutines. Users need to know that they are writing asynchronous programs.
    All calls are executed asynchronously, and there is almost no operation that occupies a thread.
        Although we also provide some facilities with semi-synchronous interfaces, they are not core features.
    We try to avoid user's derivations, and encapsulate user behavior with std::function instead, including:
        The callback of any task.
        Any server's process. This conforms to the FaaS (Function as a Service) idea.
        The realization of an algorithm is simply a std::function. But the algorithm can also be implemented by derivation.

Memory reclamation mechanism

    Every task will be automatically reclaimed after the callback. If a task is created but a user does not want to run it, the user needs to release it through the dismiss method.
    Any data in the task, such as the response of the network request, will also be recycled with the task. At this time, the user can use std::move() to move the required data.
    SeriesWork and ParallelWork are two kinds of framework objects, which are also recycled after their callback.
        When a series is a branch of a parallel, it will be recycled after the callback of the parallel that it belongs to.
    This project doesnâ€™t use std::shared_ptr to manage memory.
Get started (Linux, macOS):

git clone https://github.com/mac-oya/workflow
make
